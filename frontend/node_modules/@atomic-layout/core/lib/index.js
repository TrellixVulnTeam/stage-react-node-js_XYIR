'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const defaultOptions = {
    defaultUnit: 'px',
    defaultBehavior: 'up',
    defaultBreakpointName: 'xs',
    breakpoints: {
        xs: {
            maxWidth: '575px',
        },
        sm: {
            minWidth: '576px',
            maxWidth: '767px',
        },
        md: {
            minWidth: '768px',
            maxWidth: '991px',
        },
        lg: {
            minWidth: '992px',
            maxWidth: '1199px',
        },
        xl: {
            minWidth: '1200px',
        },
    },
};

function invariant(variable, message) {
    if (!variable) {
        throw new Error(message);
    }
}

function warn(predicate, message) {
    if (!predicate) {
        console.warn(message);
    }
}

class Layout {
    constructor(options) {
        this.defaultUnit = defaultOptions.defaultUnit;
        this.defaultBehavior = defaultOptions.defaultBehavior;
        this.breakpoints = defaultOptions.breakpoints;
        this.defaultBreakpointName = defaultOptions.defaultBreakpointName;
        this.isConfigureCalled = false;
        return options ? this.configure(options, false) : this;
    }
    /**
     * Applies global layout options.
     * Make sure to call this method once, preferably on the rool level
     * of your application.
     */
    configure(options, warnOnMultiple = true) {
        if (warnOnMultiple) {
            warn(!this.isConfigureCalled, 'Failed to configure Layout: do not call `Layout.configure()` more than once. Layout configuration must remain consistent throughout the application.');
        }
        invariant(options && typeof options === 'object', `Failed to configure Layout: expected an options Object, but got: ${options}.`);
        Object.keys(options || {}).forEach((optionName) => {
            this[optionName] = options[optionName];
        });
        invariant(this.breakpoints, 'Failed to configure Layout: expected to have at least one breakpoint specified, but got none.');
        invariant(this.breakpoints.hasOwnProperty(this.defaultBreakpointName), `Failed to configure Layout: cannot use "${this.defaultBreakpointName}" as the default breakpoint (breakpoint not found).`);
        invariant(this.defaultBreakpointName, `Failed to configure Layout: expected "defaultBreakpointName" property set, but got: ${this.defaultBreakpointName}.`);
        // Mark configure method as called to prevent its multiple calls
        this.isConfigureCalled = warnOnMultiple;
        return this;
    }
}
var Layout$1 = new Layout();

/**
 * Returns a functional composition of the given functions.
 * Applies no currying.
 */
function compose(...funcs) {
    return funcs.reduce((f, g) => (...args) => f(g(...args)));
}

function isset(variable) {
    return typeof variable !== 'undefined' && variable !== null;
}

function transformNumeric(value) {
    if (!isset(value)) {
        return '';
    }
    /**
     * Suffix numeric value with the default unit.
     * Accept explicit (string) value as-is.
     *
     * When given value is zero then its generated as it is, no suffix is attached
     */
    const suffix = typeof value === 'number' && value !== 0 ? Layout$1.defaultUnit : '';
    return `${value}${suffix}`;
}

const keywords = [
    // Dot symbol (and its sequence) is a valid placeholder,
    // but not a valid CSS Grid area name.
    /\.+/,
    // Numbers may be present in `grid-template` definition
    // and describe dimensions of rows/columns.
    /^[0-9]/,
    // Slash is a special symbol used to declare dimensions
    // for columns.
    '/',
    // "auto" is a reserved keyword to describe an automatic
    // dimension value when sizing rows/columns.
    'auto',
];
/**
 * Determines if a given string is a valid CSS Grid area name.
 * Takes into account row/column dimensions and reserved
 * keywords used in the `grid-template` definition.
 */
function isAreaName(areaName) {
    return keywords.every((keyword) => {
        return keyword instanceof RegExp
            ? !keyword.test(areaName)
            : areaName !== keyword;
    });
}

/**
 * Joins a given template string fragments into a valid template string.
 * Appends any row/column dimensions after the enclosing single quote
 * character to have a valid `grid-template` syntax.
 */
const joinTemplateFragments = (fragments) => {
    const areas = [];
    const suffixes = [];
    fragments.forEach((areaName) => {
        if (isAreaName(areaName) || /\.+/.test(areaName)) {
            areas.push(areaName);
        }
        else {
            suffixes.push(areaName);
        }
    });
    // Wraps areas string in single quote per CSS spec
    const joinedAreas = areas.length > 0 ? `'${areas.join(' ')}'` : '';
    const joinedSuffixes = suffixes.join(' ');
    // Ensures row/column dimensions follow areas list after its been
    // wrapped in single quotes.
    return [joinedAreas, joinedSuffixes].filter(Boolean).join(' ');
};
/**
 * Sanitizes a given `grid-template-areas` string.
 * Trims whitespaces, deduplicates quotes and wraps each line
 * in single quotes to be CSS-compliant.
 */
const sanitizeTemplateArea = compose(joinTemplateFragments, (area) => area.split(' '), (area) => area.replace(/'+/gm, ''), (area) => area.trim());

const transformTemplateString = compose((areas) => areas.join('\n'), (areas) => areas.map(sanitizeTemplateArea), (template) => template.split('\n'), (template) => template.trim());
/**
 * Collection of prop aliases.
 * Prop alias is a prop name accepted by a component which is later
 * substituted by one or multiple CSS properties with a single value.
 * Each prop value can have a value transformer.
 */
const propAliases = {
    /* CSS Grid */
    area: {
        props: ['grid-area'],
    },
    areas: {
        props: ['grid-template-areas'],
        transformValue: transformTemplateString,
    },
    template: {
        props: ['grid-template'],
        transformValue: transformTemplateString,
    },
    templateCols: {
        props: ['grid-template-columns'],
    },
    templateRows: {
        props: ['grid-template-rows'],
    },
    col: {
        props: ['grid-column'],
    },
    colStart: {
        props: ['grid-column-start'],
    },
    colEnd: {
        props: ['grid-column-end'],
    },
    row: {
        props: ['grid-row'],
    },
    rowStart: {
        props: ['grid-row-start'],
    },
    rowEnd: {
        props: ['grid-row-end'],
    },
    gap: {
        props: ['grid-gap'],
        transformValue: transformNumeric,
    },
    gapCol: {
        props: ['grid-column-gap'],
        transformValue: transformNumeric,
    },
    gapRow: {
        props: ['grid-row-gap'],
        transformValue: transformNumeric,
    },
    gutter: {
        props: ['grid-gap'],
        transformValue: transformNumeric,
    },
    gutterCol: {
        props: ['grid-column-gap'],
        transformValue: transformNumeric,
    },
    gutterRow: {
        props: ['grid-row-gap'],
        transformValue: transformNumeric,
    },
    autoRows: {
        props: ['grid-auto-rows'],
        transformValue: transformNumeric,
    },
    autoCols: {
        props: ['grid-auto-columns'],
        transformValue: transformNumeric,
    },
    autoFlow: {
        props: ['grid-auto-flow'],
    },
    order: {
        props: ['order'],
    },
    align: {
        props: ['align-self'],
    },
    alignItems: {
        props: ['align-items'],
    },
    alignContent: {
        props: ['align-content'],
    },
    justify: {
        props: ['justify-self'],
    },
    justifyItems: {
        props: ['justify-items'],
    },
    justifyContent: {
        props: ['justify-content'],
    },
    place: {
        props: ['place-self'],
    },
    placeItems: {
        props: ['place-items'],
    },
    placeContent: {
        props: ['place-content'],
    },
    /* CSS Flexbox */
    flexDirection: {
        props: ['flex-direction'],
    },
    flexShrink: {
        props: ['flex-shrink'],
    },
    flexGrow: {
        props: ['flex-grow'],
    },
    flexWrap: {
        props: ['flex-wrap'],
    },
    /* Dimensions */
    height: {
        props: ['height'],
        transformValue: transformNumeric,
    },
    minHeight: {
        props: ['min-height'],
        transformValue: transformNumeric,
    },
    maxHeight: {
        props: ['max-height'],
        transformValue: transformNumeric,
    },
    width: {
        props: ['width'],
        transformValue: transformNumeric,
    },
    minWidth: {
        props: ['min-width'],
        transformValue: transformNumeric,
    },
    maxWidth: {
        props: ['max-width'],
        transformValue: transformNumeric,
    },
    /* Space */
    margin: {
        props: ['margin'],
        transformValue: transformNumeric,
    },
    marginTop: {
        props: ['margin-top'],
        transformValue: transformNumeric,
    },
    marginRight: {
        props: ['margin-right'],
        transformValue: transformNumeric,
    },
    marginBottom: {
        props: ['margin-bottom'],
        transformValue: transformNumeric,
    },
    marginLeft: {
        props: ['margin-left'],
        transformValue: transformNumeric,
    },
    marginVertical: {
        props: ['margin-top', 'margin-bottom'],
        transformValue: transformNumeric,
    },
    marginHorizontal: {
        props: ['margin-right', 'margin-left'],
        transformValue: transformNumeric,
    },
    padding: {
        props: ['padding'],
        transformValue: transformNumeric,
    },
    paddingTop: {
        props: ['padding-top'],
        transformValue: transformNumeric,
    },
    paddingRight: {
        props: ['padding-right'],
        transformValue: transformNumeric,
    },
    paddingBottom: {
        props: ['padding-bottom'],
        transformValue: transformNumeric,
    },
    paddingLeft: {
        props: ['padding-left'],
        transformValue: transformNumeric,
    },
    paddingVertical: {
        props: ['padding-top', 'padding-bottom'],
        transformValue: transformNumeric,
    },
    paddingHorizontal: {
        props: ['padding-right', 'padding-left'],
        transformValue: transformNumeric,
    },
};

function toLowerCaseFirst(str) {
    return (str.slice(0, 1).toLowerCase() + str.slice(1, str.length));
}

function capitalize(str) {
    return str.replace(/^./, (firstLetter) => firstLetter.toUpperCase());
}

/**
 * Returns a parsed prop summary, which includes pure prop name,
 * an optional breakpoint name and breakpoint behavior.
 *
 * \w+(?<=(sm)?(only)?)$
 * This RegExp also works well. May consider implementing once
 * lookbehind is supported everywhere.
 */
function parsePropName(originPropName) {
    const joinedBreakpointNames = Object.keys(Layout$1.breakpoints)
        .map(capitalize)
        .join('|');
    const joinedBehaviors = ['down', 'only'].map(capitalize).join('|');
    const breakpointExp = new RegExp(`(${joinedBreakpointNames})$`, 'g');
    const behaviorExp = new RegExp(`(${joinedBehaviors})$`, 'g');
    const behaviorMatch = originPropName.match(behaviorExp);
    const behavior = behaviorMatch ? behaviorMatch[0] : '';
    const breakpointMatch = originPropName
        .replace(behavior, '')
        .match(breakpointExp);
    const breakpointName = breakpointMatch ? breakpointMatch[0] : '';
    const purePropName = originPropName
        .replace(breakpointName, '')
        .replace(behavior, '');
    /**
     * Get normalized breakpoint name.
     * When a breakpoint name is a part of the prop name, covert it first letter
     * to lowercase to match the layout options. Otherwise, take the default
     * breakpoint name.
     */
    const normalizedBreakpointName = breakpointName
        ? toLowerCaseFirst(breakpointName)
        : Layout$1.defaultBreakpointName;
    const isDefaultBreakpoint = normalizedBreakpointName === Layout$1.defaultBreakpointName;
    return {
        originPropName,
        purePropName,
        behavior: behavior
            ? toLowerCaseFirst(behavior)
            : Layout$1.defaultBehavior,
        breakpoint: {
            name: normalizedBreakpointName,
            isDefault: isDefaultBreakpoint,
        },
    };
}

/**
 * Converts given cammelCase string into kebab-case.
 * @example
 * toDashedString('fooBar')
 * @returns "foo-bar"
 */
function toDashedString(str) {
    return str.replace(/[A-Z]/g, (capitalLetter) => {
        return `-${capitalLetter}`.toLowerCase();
    });
}

/**
 * Normalizes given media query object to a list of [propName, propValue].
 * @example
 * normalizeQuery({ minWidth: 120 })
 * // [['min-width', 120]]
 */
function normalizeQuery(queryProps) {
    return Object.entries(queryProps)
        .filter(([_, propValue]) => isset(propValue))
        .map(([propName, propValue]) => [
        toDashedString(propName),
        propValue,
    ]);
}

/**
 * Determines whether a given media query param should be added
 * to the media query string based on a breakpoint's behavior.
 */
const shouldAppendProperty = (queryParam, behavior) => {
    const [prefix, splitPropName] = queryParam.split('-');
    const isDimensionalProp = ['height', 'width'].includes(splitPropName);
    if (!isDimensionalProp) {
        return true;
    }
    return ((prefix === 'min' && ['up', 'only'].includes(behavior)) ||
        (prefix === 'max' && ['down', 'only'].includes(behavior)));
};
const filterRelevantQueryParams = (behavior) => (queryList) => {
    return queryList.filter(([queryParam]) => shouldAppendProperty(queryParam, behavior));
};
/**
 * Joins a given media query params list with the given transformer function.
 */
const joinQueryList = (transformer) => (queryList) => {
    return queryList.map(transformer).join(' and ');
};
function createMediaQuery(breakpoint, behavior) {
    return compose(joinQueryList(([dashedQueryProp, propValue]) => {
        return `(${dashedQueryProp}:${String(transformNumeric(propValue))})`;
    }), filterRelevantQueryParams(behavior), normalizeQuery)(breakpoint);
}

/**
 * Generateds a single CSS string for the set of props,
 * value, and its responsive information.
 */
const createStyleString = (cssProps, propValue, parsedBreakpoint, behavior) => {
    const styleString = cssProps
        .map((propName) => `${propName}:${String(propValue)};`)
        .join('');
    // Get a breakpoint dimensions based on the statically analyzed breakpoint.
    const breakpointOptions = Layout$1.breakpoints[parsedBreakpoint.name];
    // Wrap CSS rule in a media query only if its prop includes
    // a breakpoint and behavior different from the default ones.
    const shouldWrapInMediaQuery = breakpointOptions &&
        !(parsedBreakpoint.isDefault && behavior === Layout$1.defaultBehavior);
    return shouldWrapInMediaQuery
        ? `@media ${createMediaQuery(breakpointOptions, behavior)} {${styleString}}`
        : styleString;
};
/**
 * Transforms known prop aliases to CSS rules for the given props.
 */
function applyStyles(pristineProps) {
    return (Object.keys(pristineProps)
        // Parse each prop to include "breakpoint" and "behavior"
        .map(parsePropName)
        // Filter out props that are not included in prop aliases
        .filter(({ purePropName }) => propAliases.hasOwnProperty(purePropName))
        // Filter out props with "undefined" or "null" as value
        .filter(({ originPropName }) => isset(pristineProps[originPropName]))
        // Map each prop to a CSS rule string
        .map(({ purePropName, originPropName, breakpoint, behavior }) => {
        const { props, transformValue } = propAliases[purePropName];
        const propValue = pristineProps[originPropName];
        const transformedPropValue = transformValue
            ? transformValue(propValue)
            : propValue;
        return createStyleString(props, transformedPropValue, breakpoint, behavior);
    })
        .join(' '));
}

const createWithBreakpoints = (breakpoints) => {
    const existingBreakpoints = Object.keys(breakpoints);
    return (breakpointsMap, defaultValue) => {
        const breakpointMatch = Object.keys(breakpointsMap)
            .filter((breakpointName) => {
            const hasBreakpoint = existingBreakpoints.includes(breakpointName);
            if (!hasBreakpoint) {
                console.warn('useBreakpoints: Breakpoint "%s" is not found. Add it via "Layout.configure()", or use one of the existing breakpoints (%s).', breakpointName, existingBreakpoints.join(', '));
            }
            return hasBreakpoint;
        })
            .find((breakpointName) => {
            const breakpoint = breakpoints[breakpointName];
            const mediaQuery = createMediaQuery(breakpoint, 'only');
            return breakpoint && matchMedia(mediaQuery).matches;
        });
        return breakpointMatch ? breakpointsMap[breakpointMatch] : defaultValue;
    };
};
const withBreakpoints = createWithBreakpoints(Layout$1.breakpoints);

function getPrefix(str) {
    const prompt = str.match(/^(min|max)/);
    return prompt ? prompt[0] : '';
}

/**
 * Opens the given breakpoint.
 * A breakpoint is considered open when it has no upper boundary. For example,
 * a breakpoint that has "maxWidth: undefined" is the open breakpoint.
 */
function openBreakpoint(breakpoint) {
    return Object.keys(breakpoint).reduce((acc, key) => ({
        ...acc,
        [key]: getPrefix(key) === 'max' ? undefined : breakpoint[key],
    }), {});
}

/**
 * Accepts a breakpoint and returns a new breakpoint where
 * all the "min" properties of the original breakpoint are
 * flipped into the "max" properties. Any "max" properties
 * of the original breakpoint are omitted.
 * Subtracts 1 from the numeric values of all "min" properties
 * to not overlap with the given breakpoint.
 *
 * @example
 * flipBreakpoint({ minWidth: 500, maxWidth: 600 })
 * // { maxWidth: 499 }
 */
function flipBreakpoint(breakpoint) {
    return Object.entries(breakpoint)
        .map(([propName, propValue]) => [
        getPrefix(propName),
        propName,
        propValue,
    ])
        .filter(([prefix]) => prefix !== 'max')
        .reduce((newBreakpoint, [prefix, propName, propValue]) => {
        const hasMinPrefix = prefix === 'min';
        const nextPropName = hasMinPrefix
            ? propName.replace(/^min/, 'max')
            : propName;
        // Parse a breakpoint property value into a numeric value
        // and its measurement unit.
        const [, numericValue, unit] = /(\d+)(.+)?/.exec(propValue);
        /**
         * Subtracts 1 from the edge to not include the area at the beginning
         * of the breakpoint.
         *
         * @todo
         * How is "parseFloat" going to work with non-dimensional options?
         * (i.e. aspectRatio)
         */
        const nextNumericValue = hasMinPrefix
            ? parseFloat(numericValue) - 1
            : numericValue;
        // Append back the measurement unit.
        // Prevents breakpoints like { "minWidth": "768px" }
        // becoming { "minWidth": 768 } -> { "minWidth": "768rem" }
        // when the measurement unit is not "px".
        const nextValue = unit ? `${nextNumericValue}${unit}` : nextNumericValue;
        return {
            ...newBreakpoint,
            [nextPropName]: nextValue,
        };
    }, {});
}

/**
 * Merges two given area records.
 */
function mergeAreaRecords(nextAreaRecord, prevAreaRecord, includesArea) {
    const { behavior: prevRecordBehavior } = prevAreaRecord;
    const { behavior: nextRecordBehavior } = nextAreaRecord;
    const wentUp = prevRecordBehavior === 'up';
    const goesDown = nextRecordBehavior === 'down';
    const behavesSame = prevRecordBehavior === nextRecordBehavior;
    const behavesInclusive = wentUp && goesDown;
    const shouldStretch = wentUp;
    const nextBehavior = !includesArea && shouldStretch ? 'down' : nextRecordBehavior;
    const mergedBreakpoint = {
        ...prevAreaRecord.breakpoint,
        ...nextAreaRecord.breakpoint,
    };
    const nextBreakpoint = Object.keys(mergedBreakpoint).reduce((acc, propName) => {
        let nextValue = mergedBreakpoint[propName];
        const prefix = getPrefix(propName);
        if (prefix === 'max') {
            if (!includesArea && shouldStretch) {
                const reversedValue = nextAreaRecord.breakpoint[propName.replace(/^max/, 'min')];
                nextValue = `calc(${transformNumeric(reversedValue)} - 1px)`;
            }
        }
        if (prefix === 'min') {
            if (includesArea) {
                if (behavesSame || behavesInclusive) {
                    nextValue = prevAreaRecord.breakpoint[propName];
                }
            }
            else {
                if (shouldStretch) {
                    nextValue = prevAreaRecord.breakpoint[propName];
                }
            }
        }
        return {
            ...acc,
            [propName]: nextValue,
        };
    }, {});
    return {
        behavior: nextBehavior,
        breakpoint: nextBreakpoint,
    };
}

/**
 * Returns an array of unique normalized grid area names
 * from the given template string. Any member of the returned list
 * is later evolved into a React component.
 */
const sanitizeTemplateString = compose((list) => list.sort(), 
// Deduplicate area strings
(list) => Array.from(new Set(list)), 
// Filter out "template" row/columns sizes
(arr) => arr.filter(isAreaName), 
// Filter out empty area strings
(arr) => arr.filter(Boolean), 
// Split into a list of areas
(str) => str.split(' '), 
// Deduplicate multiple spaces
(str) => str.replace(/\s+/g, ' '), 
// Replace new lines and single quotes with spaces
(str) => str.replace(/\r?\n|\'+/g, ' '));

/**
 * Accepts a props object and filters it to include
 * only template-related prop:value pairs.
 */
const filterTemplateProps = (props) => {
    return Object.keys(props)
        .filter((propName) => {
        const { purePropName } = parsePropName(propName);
        return ['areas', 'template'].includes(purePropName);
    })
        .reduce((acc, propName) => {
        return {
            ...acc,
            [propName]: sanitizeTemplateString(props[propName]),
        };
    }, {});
};

function getAreasList(templateProps) {
    const areasList = Object.entries(templateProps).reduce((acc, [templateName, templateAreas]) => {
        const { breakpoint, behavior } = parsePropName(templateName);
        const nextAreas = acc.areas.concat(templateAreas);
        const nextTemplates = acc.templates.concat({
            breakpoint: Layout$1.breakpoints[breakpoint.name],
            behavior,
            areas: templateAreas,
        });
        return {
            areas: nextAreas,
            templates: nextTemplates,
        };
    }, {
        areas: [],
        templates: [],
    });
    const { areas, templates } = areasList;
    return {
        areas: Array.from(new Set(areas)),
        templates,
    };
}

const memoizeWith = (saltGenerator) => {
    const cache = {};
    return (func) => function (...args) {
        const key = saltGenerator(...args);
        if (!(key in cache)) {
            cache[key] = func(...args);
        }
        return cache[key];
    };
};

function hashString(str) {
    const { length } = str;
    let hash = 0;
    let i = 0;
    if (length > 0) {
        while (i < length) {
            hash = ((hash << 5) - hash + str.charCodeAt(i++)) | 0;
        }
    }
    return hash;
}

/**
 * Memoize areas generation based on the sanitized "templateProp:areas" pairs.
 * Alphabetical sorting of incoming template areas allows reproducible cache keys.
 * @todo `pairs` is an empty array sometimes. Should we handle it somehow?
 */
const memoizeProps = memoizeWith((templateProps) => {
    const pairs = Object.entries(templateProps).reduce((acc, [propName, templateAreas]) => {
        return acc.concat(`${propName}:${templateAreas.join()}`);
    }, []);
    return hashString(pairs.join()).toString();
});
/**
 * Parses a given map of props and returns an areas map.
 */
const parseTemplates = compose(memoizeProps(getAreasList), filterTemplateProps);

/**
 * Returns the shallow copy of the given array with
 * the last element removed.
 */
function pop(list) {
    return list.slice(0, list.length - 1);
}

/**
 * Replaces the prefixes in a parameter name.
 * Allows strict comparison of same parameters with different prefixes.
 * Does not test for inclusion/notch.
 *
 * @example
 * neutralizeParamName('maxWidth') // "_width"
 * neutralizeParamName('minWidth') // "_width"
 */
const neutralizeParamName = (paramName) => {
    return paramName.replace(/^min|max/, '_');
};
/**
 * Determines whether two given breakpoints can be merged.
 * Assures non-compatible breakpoints are not prompted to
 * be merged during the area params composition.
 */
function shouldCombineBreakpoints(breakpointA, breakpointB) {
    const allParams = Object.keys(breakpointA).concat(Object.keys(breakpointB));
    return allParams.every((pristineParamName, index) => {
        const paramName = neutralizeParamName(pristineParamName);
        const prevParamName = neutralizeParamName(allParams[index - 1] || paramName);
        return paramName === prevParamName;
    });
}

const canMergeRecords = (prevRecord, nextRecord) => {
    const hasSameBehavior = prevRecord.behavior === nextRecord.behavior;
    const hasInclusiveBehavior = prevRecord.behavior === 'up' && nextRecord.behavior === 'down';
    const shouldMergeRecords = hasSameBehavior || hasInclusiveBehavior;
    if (!shouldMergeRecords) {
        return false;
    }
    // Check if breakpoints are compatible to be merged
    return shouldCombineBreakpoints(prevRecord.breakpoint, nextRecord.breakpoint);
};
const handleLastRecord = (isLastTempate, areaRecord) => {
    return {
        behavior: areaRecord.behavior,
        breakpoint: isLastTempate && areaRecord.behavior === 'up'
            ? openBreakpoint(areaRecord.breakpoint)
            : areaRecord.breakpoint,
    };
};
function getAreaRecords(areaName, templates) {
    const templatesCount = templates.length;
    return templates.reduce((list, template, index) => {
        const { areas, behavior, breakpoint } = template;
        // Important to know if operating on the last record
        // to properly construct the trailing breakpoint.
        const isLastTempate = index === templatesCount - 1;
        const includesArea = areas.includes(areaName);
        const areaRecord = {
            breakpoint,
            behavior,
        };
        const lastAreaRecord = list[list.length - 1];
        if (includesArea) {
            const shouldMergeRecords = lastAreaRecord && canMergeRecords(lastAreaRecord, areaRecord);
            if (shouldMergeRecords) {
                const mergedAreaRecord = mergeAreaRecords(areaRecord, lastAreaRecord, includesArea);
                // Replace the preceding area record with the merged instance.
                return pop(list).concat(handleLastRecord(isLastTempate, mergedAreaRecord));
            }
            // Append the new area record.
            return list.concat(handleLastRecord(isLastTempate, areaRecord));
        }
        // When the area is not present in the current template
        // check if the preceding area record exists. If so,
        // make sure to close it to prevent it from rendering on this breakpoint.
        if (lastAreaRecord) {
            /**
             * @todo Confusing that "merge" also closes the breakpoint.
             * Also it needs prev and next. Uh.
             */
            const closedLastAreaRecord = mergeAreaRecords(areaRecord, lastAreaRecord, includesArea);
            return pop(list).concat([closedLastAreaRecord, null]);
        }
        // Appending explicit "null" creates a separation between breakpoints
        // that prevents them being treated like siblings. Breakpoints separated
        // by "null" are not attempted to be merged, or analyzed together in any way.
        return list.concat(null);
    }, []);
}

/**
 * Returns a map of React components based on the given grid areas
 * in the given template definitions.
 */
function generateComponents({ areas, templates }, createAreaComponent, withPlaceholder) {
    const componentsMap = areas.reduce((components, areaName) => {
        const areaRecords = getAreaRecords(areaName, templates);
        const areaBreakpoints = areaRecords
            .filter(Boolean)
            .map((areaRecord) => areaRecord.breakpoint);
        const shouldAlwaysRender = areaRecords.length === 1 &&
            areaBreakpoints.every((breakpoint) => !breakpoint.minWidth && !breakpoint.maxWidth);
        const Component = createAreaComponent(areaName);
        const capitalizedAreaName = capitalize(areaName);
        Component.displayName = `Area(${capitalizedAreaName})`;
        const ResponsiveComponent = shouldAlwaysRender
            ? Component
            : withPlaceholder(Component, areaBreakpoints);
        return {
            ...components,
            [capitalizedAreaName]: ResponsiveComponent,
        };
    }, {});
    // Return plain components map for browsers that don't support Proxy.
    // Requires safety check before rendering conditional areas.
    return typeof Proxy === 'undefined'
        ? componentsMap
        : new Proxy(componentsMap, {
            get(components, areaName) {
                if (areaName in components || typeof areaName === 'symbol') {
                    return components[areaName];
                }
                // Replace non-existing area component with
                // the dummy component that renders nothing.
                // This prevents from the exception when rendering "undefined"
                // and allows dynamic runtime template areas.
                return () => null;
            },
        });
}

/**
 * Throttles a given function.
 * Implements both leading and trailing function calls.
 */
function throttle(func, interval) {
    let previous;
    let queuedToRun = null;
    return function invoker(...args) {
        const now = Date.now();
        clearTimeout(queuedToRun);
        if (!previous || now - previous >= interval) {
            func.apply(null, args);
            previous = now;
        }
        else {
            queuedToRun = setTimeout(invoker.bind(null, ...args), interval - (now - previous));
        }
    };
}

exports.Layout = Layout$1;
exports.applyStyles = applyStyles;
exports.closeBreakpoint = flipBreakpoint;
exports.compose = compose;
exports.createMediaQuery = createMediaQuery;
exports.defaultOptions = defaultOptions;
exports.generateComponents = generateComponents;
exports.joinQueryList = joinQueryList;
exports.memoizeWith = memoizeWith;
exports.mergeAreaRecords = mergeAreaRecords;
exports.normalizeQuery = normalizeQuery;
exports.openBreakpoint = openBreakpoint;
exports.parsePropName = parsePropName;
exports.parseTemplates = parseTemplates;
exports.propAliases = propAliases;
exports.throttle = throttle;
exports.transformNumeric = transformNumeric;
exports.warn = warn;
exports.withBreakpoints = withBreakpoints;
