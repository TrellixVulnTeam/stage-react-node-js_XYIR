import { applyStyles, compose, joinQueryList, transformNumeric, normalizeQuery, parseTemplates, generateComponents, warn, throttle, Layout, mergeAreaRecords, closeBreakpoint, openBreakpoint, memoizeWith, createMediaQuery as createMediaQuery$1, withBreakpoints, parsePropName } from '@atomic-layout/core';
import styled from 'styled-components';
import React__default, { forwardRef as forwardRef$1, useState, useMemo, useEffect, useLayoutEffect, createElement, useRef } from 'react';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  display: ", ";\n\n  && {\n    ", ";\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}
var Box = styled.div(_templateObject(), function (_ref) {
  var flex = _ref.flex,
      inline = _ref.inline;
  return flex ? inline ? 'inline-flex' : 'flex' : inline ? 'inline-block' : 'block';
}, applyStyles);
Box.displayName = 'Box';

var forwardRef = function forwardRef(component) {
  return forwardRef$1(component);
};

/**
 * Creates a media querty string based on the given params.
 */

var createMediaQuery = function createMediaQuery(queryParams) {
  return compose(joinQueryList(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        paramName = _ref2[0],
        paramValue = _ref2[1];

    /**
     * Transform values that begin with a number to prevent
     * transformations of "calc" expressions.
     * Transformation of numerics is necessary when a simple
     * number is used as a value (min-width: 750) is not valid.
     *
     * (min-width: 750) ==> (min-width: 750px)
     */
    var resolvedParamValue = /^\d/.test(String(paramValue)) ? transformNumeric(paramValue) : paramValue;
    return "(".concat(paramName, ":").concat(resolvedParamValue, ")");
  }), normalizeQuery)(queryParams);
};
var useMediaQuery = function useMediaQuery(queryParams) {
  var initialMatches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var useSafeEffect = typeof window === 'undefined' ? useEffect : useLayoutEffect;

  var _useState = useState(initialMatches),
      _useState2 = _slicedToArray(_useState, 2),
      matches = _useState2[0],
      setMatches = _useState2[1];

  var query = useMemo(function () {
    return [].concat(queryParams).map(createMediaQuery).join(',');
  }, [queryParams]);

  var handleMediaQueryChange = function handleMediaQueryChange(mediaQueryList) {
    setMatches(mediaQueryList.matches);
  };

  useSafeEffect(function () {
    var mediaQueryList = matchMedia(query);
    handleMediaQueryChange(mediaQueryList);
    mediaQueryList.addListener(handleMediaQueryChange);
    return function () {
      mediaQueryList.removeListener(handleMediaQueryChange);
    };
  }, Object.keys(queryParams));
  return matches;
};

/**
 * Wraps the given area component in a placeholder component.
 * This is used for conditional components, where placeholder component is rendered
 * until the condition for that area component is met (i.e. viewport matches a breakpoint).
 */

var withPlaceholder = function withPlaceholder(Component, breakpoints) {
  var Placeholder = forwardRef(function (_ref, ref) {
    var children = _ref.children,
        restProps = _objectWithoutProperties(_ref, ["children"]);

    var matches = useMediaQuery(breakpoints);
    return matches && createElement(Component, Object.assign({
      ref: ref
    }, restProps), children);
  });
  Placeholder.displayName = "Placeholder(".concat(Component.displayName, ")");
  return Placeholder;
};

function _templateObject$1() {
  var data = _taggedTemplateLiteral(["\n  && {\n    ", ";\n    display: ", ";\n  }\n"]);

  _templateObject$1 = function _templateObject() {
    return data;
  };

  return data;
}
var CompositionWrapper = styled.div(_templateObject$1(), applyStyles, function (_ref) {
  var inline = _ref.inline;
  return inline ? 'inline-grid' : 'grid';
});

var createAreaComponent = function createAreaComponent(areaName) {
  return forwardRef(function (props, ref) {
    return createElement(Box, Object.assign({
      ref: ref,
      area: areaName
    }, props));
  });
};

var Composition = forwardRef(function (_ref2, ref) {
  var children = _ref2.children,
      restProps = _objectWithoutProperties(_ref2, ["children"]);

  var areasList = parseTemplates(restProps); // Memoize areas generation so parental updates do not re-generate areas,
  // making area components preserve their internal state.

  var Areas = useMemo(function () {
    return generateComponents(areasList, createAreaComponent, withPlaceholder);
  }, [areasList]);
  var hasAreaComponents = Object.keys(Areas).length > 0;

  var childrenType = _typeof(children);

  var hasChildrenFunction = childrenType === 'function'; // Warn when provided "areas"/"template" props, but didn't use a render prop pattern.

  warn(!(hasAreaComponents && !hasChildrenFunction), "Failed to render 'Composition' with template areas [\"".concat(Object.keys(Areas).join('", "'), "\"]: expected children to be a function, but got: ").concat(childrenType, ". Please provide render function as children, or remove assigned template props (`areas`/`template`)."));
  return createElement(CompositionWrapper, Object.assign({
    ref: ref
  }, restProps), hasAreaComponents && hasChildrenFunction ? children(Areas) : children);
});
Composition.displayName = 'Composition';

/**
 * Executes a callback on viewport change (window resize).
 * Callback calls are throttled by default.
 */

var useViewportChange = function useViewportChange(callback) {
  var throttleInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 70;
  var handleWindowResize = useRef();
  useEffect(function () {
    handleWindowResize.current = throttle(callback, throttleInterval);
  });
  useEffect(function () {
    var current = handleWindowResize.current;
    current();
    window.addEventListener('resize', current);
    return function () {
      return window.removeEventListener('resize', current);
    };
  }, []);
};

var resolveBreakpoint = function resolveBreakpoint(breakpointRef) {
  return typeof breakpointRef === 'string' ? Layout.breakpoints[breakpointRef] : breakpointRef;
};
/**
 * Returns a list of breakpoints based on a responsive query.
 * @example
 * getBreakpointsByQuery({ from: 'md' })
 * // [{ minWidth: 768 }]
 * getBreakpointsByQuery({ from: 'sm', to: 'lg' })
 * // [{ minWidth: 576 }, { maxWidth: 1199 }]
 */

var getBreakpointsByQuery = function getBreakpointsByQuery(params) {
  var exactBreakpoint = params["for"],
      from = params.from,
      to = params.to,
      except = params.except; // Explicit breakpoint

  if (exactBreakpoint) {
    return [resolveBreakpoint(exactBreakpoint)];
  }

  var minBreakpoint = resolveBreakpoint(from);
  var maxBreakpoint = resolveBreakpoint(to); // Bell, __/--\__

  if (minBreakpoint && maxBreakpoint && !except) {
    var mergedAreaRecord = mergeAreaRecords({
      behavior: 'down',
      breakpoint: maxBreakpoint
    }, {
      behavior: 'up',
      breakpoint: minBreakpoint
    }, false);
    return [mergedAreaRecord.breakpoint];
  } // Notch, --\__/--


  if (minBreakpoint && maxBreakpoint && except) {
    return [closeBreakpoint(minBreakpoint), openBreakpoint(maxBreakpoint)];
  } // High-pass, __/--


  if (minBreakpoint && !maxBreakpoint) {
    return [openBreakpoint(minBreakpoint)];
  } // Low-pass, --\__


  if (!minBreakpoint && maxBreakpoint) {
    return [closeBreakpoint(maxBreakpoint)];
  }

  return [];
};

var createQuery = function createQuery(params) {
  var breakpoints = getBreakpointsByQuery(params);
  return breakpoints.map(createMediaQuery).join(params.except ? ',' : ' ');
};
/**
 * Converts a responsive query into a @media query string.
 * @example
 * query({ from: 'md' })
 * // (min-width: 768px)
 * query({ from: 'sm', to: 'lg' })
 * // (min-width: 576px) and (max-width: 1199px)
 * query({ for: 'md' })
 * // (min-width: 768px) and (max-width: 991px)
 * query({ except: true, from: 'sm', to: 'lg' })
 * // (max-width: 575px), (min-width: 992px)
 */


var query = memoizeWith(function (params) {
  return Object.entries(params).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        value = _ref2[1];

    return value != null;
  }).reduce(function (acc, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        value = _ref4[1];

    return acc.concat("".concat(key, "=").concat(value.toString()));
  }, []).join();
})(createQuery);

/**
 * Returns a boolean indicating that the current viewport matches the given responsive query.
 * @example
 * const matches = useResponsiveQuery({ from: 'sm', to: 'lg' })
 * const matches = useResponsiveQuery({ except: true, from: 'md', to: 'lg' })
 */

function useResponsiveQuery(params) {
  var initialMatches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var _useState = useState(initialMatches),
      _useState2 = _slicedToArray(_useState, 2),
      matches = _useState2[0],
      setMatches = _useState2[1];

  var mediaQuery = query(params);
  useViewportChange(function () {
    var _matchMedia = matchMedia(mediaQuery),
        hasMatchingQuery = _matchMedia.matches;

    setMatches(hasMatchingQuery);
  });
  return matches;
}

var Only = forwardRef(function (_ref, ref) {
  var children = _ref.children,
      except = _ref.except,
      exactBreakpoint = _ref["for"],
      from = _ref.from,
      to = _ref.to,
      restProps = _objectWithoutProperties(_ref, ["children", "except", "for", "from", "to"]);

  var matches = useResponsiveQuery({
    "for": exactBreakpoint,
    from: from,
    to: to,
    except: except
  });
  return matches && createElement(Box, Object.assign({
    ref: ref
  }, restProps), children);
});
Only.displayName = 'Only';

function _templateObject$2() {
  var data = _taggedTemplateLiteral(["\n  ", "\n"]);

  _templateObject$2 = function _templateObject() {
    return data;
  };

  return data;
}
var VisibleContainer = styled(Box)(_templateObject$2(), function (_ref) {
  var matches = _ref.matches;
  return !matches && "\n      visibility: hidden;\n    ";
});
var Visible = forwardRef(function (_ref2, ref) {
  var children = _ref2.children,
      except = _ref2.except,
      exactBreakpointName = _ref2["for"],
      from = _ref2.from,
      to = _ref2.to,
      boxProps = _objectWithoutProperties(_ref2, ["children", "except", "for", "from", "to"]);

  var matches = useResponsiveQuery({
    except: except,
    "for": exactBreakpointName,
    from: from,
    to: to
  });
  var ariaAttributes = !matches ? {
    'aria-hidden': 'true'
  } : {};
  return React__default.createElement(VisibleContainer, Object.assign({
    ref: ref
  }, boxProps, ariaAttributes, {
    matches: matches
  }), children);
});
Visible.displayName = 'Visible';

/**
 * Executes a given callback upon any breakpoint change.
 * Callback calls are throttled by default.
 */

var useBreakpointChange = function useBreakpointChange(callback, throttleInterval) {
  var breakpoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Layout.breakpoints;
  var prevBreakpointName;
  useViewportChange(function () {
    var nextBreakpointName = Object.keys(breakpoints).find(function (breakpointName) {
      var mediaQuery = createMediaQuery$1(breakpoints[breakpointName], 'only');
      return matchMedia(mediaQuery).matches;
    }); // Executes the callback only when breakpoint name has changed
    // between viewport changes.

    if (prevBreakpointName !== nextBreakpointName) {
      callback(nextBreakpointName);
      prevBreakpointName = nextBreakpointName;
    }
  }, throttleInterval);
};

/**
 * Accepts a map of { breakpointName: value } pairs
 * and returns a value based on the current viewport.
 * Returns default value when no matching pair is found.
 */

var useResponsiveValue = function useResponsiveValue(breakpoints, defaultValue) {
  var _useState = useState(defaultValue),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var callback = function callback() {
    var nextValue = withBreakpoints(breakpoints, defaultValue);
    setValue(nextValue);
  };

  useEffect(callback, [breakpoints, defaultValue]);
  useBreakpointChange(callback);
  return value;
};

/**
 * Default responsive props matcher.
 * Creates a media query based on the given prop's breakpoint
 * and uses native "window.matchMedia" to assert the match.
 */

var defaultMatcher = function defaultMatcher(parsedProp) {
  var breakpoint = parsedProp.breakpoint,
      behavior = parsedProp.behavior;
  var mediaQuery = createMediaQuery$1(Layout.breakpoints[breakpoint.name], behavior);
  return matchMedia(mediaQuery).matches;
};
/**
 * Server-side responsive props matcher.
 * Apply props with the default breakpoint on the server.
 * Server assumes the default breakpoint is currently present.
 *
 * @TODO Resolve for non-default breakpoints.
 * @see https://github.com/kettanaito/atomic-layout/issues/284
 */


var serverMatcher = function serverMatcher(parsedProp) {
  var breakpoint = parsedProp.breakpoint;
  return breakpoint.isDefault && typeof window === 'undefined';
};
/**
 * Filters given responsive props against the browser state.
 * Accepts an optional matcher function to operate on a server.
 */


var filterProps = function filterProps(props) {
  var matcher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMatcher;
  return Object.keys(props).map(parsePropName).filter(matcher).reduce(function (acc, _ref) {
    var originPropName = _ref.originPropName,
        purePropName = _ref.purePropName;
    return _objectSpread2({}, acc, _defineProperty({}, purePropName, props[originPropName]));
  }, {});
};
/**
 * Accepts an object of responsive props and returns
 * an object of props relative to the current viewport.
 */


var useResponsiveProps = function useResponsiveProps(responsiveProps) {
  var _useState = useState(filterProps(responsiveProps, serverMatcher)),
      _useState2 = _slicedToArray(_useState, 2),
      props = _useState2[0],
      setProps = _useState2[1];

  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      breakpointName = _useState4[0],
      setBreakpointName = _useState4[1];

  var resolveProps = function resolveProps(inputProps) {
    return filterProps(inputProps);
  }; // Store the current breakpoint name in the state.
  // That way props update effect below can re-evaluate whenever
  // a breakpoint changes.
  // When the next prop resolver is given directly to "useBreakpointChange"
  // it always resolves the input "responsiveProps" to their initial value.
  // Using `useCallback()` hook doesn't help.


  useBreakpointChange(setBreakpointName); // Update props whenever input props change.
  // Required to trigger re-render on props change.

  useEffect(function () {
    var nextProps = resolveProps(responsiveProps);
    setProps(nextProps);
  }, [responsiveProps, breakpointName]);
  return props || {};
};

/**
 * Returns a new React component based on the given one
 * that enables support for Responsive Props API on arbitrary props.
 */

function makeResponsive(Component) {
  return React__default.forwardRef(function (responsiveProps, ref) {
    /**
     * @see https://github.com/Microsoft/TypeScript/issues/29049
     */
    var actualProps = useResponsiveProps(responsiveProps);
    return React__default.createElement(Component, Object.assign({
      ref: ref
    }, actualProps));
  });
}

export default Layout;
export { Box, Composition, Only, Visible, makeResponsive, query, useBreakpointChange, useMediaQuery, useResponsiveProps, useResponsiveQuery, useResponsiveValue, useViewportChange };
//# sourceMappingURL=index.js.map
